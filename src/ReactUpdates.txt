@startuml
title ReactUpdates
Entity ReactUpdates
participant batchedUpdates
Entity batchingStrategy
Entity Transaction
==batchedUpdates==
[-> ReactUpdates: batchedUpdates(callback, ...)
ReactUpdates -> batchedUpdates: (...)
batchedUpdates -> batchedUpdates: ensure ReactReconcilerTransaction/batchingStrategy injected
batchedUpdates -> batchingStrategy: batchedUpdates(calback, ...)
batchedUpdates -> batchedUpdates: batching = true
alt if already batching
  batchingStrategy -> batchedUpdates: callback(...)
else
  batchingStrategy -> Transaction: **Start**: nothing
  batchingStrategy -> Transaction: **perform**: (callback, ...)
  batchingStrategy -> Transaction: **close**: flush_updates, reset_batch_status, 
  Transaction -> ReactUpdates: **close**: flush_updates
==updates==
  ReactUpdates -> flushBatchedUpdates: close(...)
  create ReactUpdatesFlushTransaction
  flushBatchedUpdates -> ReactUpdatesFlushTransaction: getPooled()
  ReactUpdatesFlushTransaction -> Transaction: : **Start**: record dirtyComponents length, reset updatequeue
  ReactUpdatesFlushTransaction -> Transaction: : **perform**: ReactReconcileTransaction(runBatchedUpdates)
  ReactUpdatesFlushTransaction -> Transaction: : **close**: flush updates if has dirtyComponents, perform callbacks
  Transaction -> ReactReconcileTransaction: perform
  ReactReconcileTransaction -> Transaction: **Start**: record selection, supress event, reset MountReadyQueue
  ReactReconcileTransaction -> Transaction: **perform**: runBatchedUpdates,
  ReactReconcileTransaction -> Transaction: **close**: restore selection, enable event, perform MountReadyCallback
  Transaction -> runBatchedUpdates: perform
  loop dirtyComponents
    runBatchedUpdates -> ReactConciler: performUpdateIfNecessary()
    runBatchedUpdates -> ReactUpdatesFlushTransaction: enqueue component._calbacks
  end
  Transaction -> ReactReconcileTransaction: **close**
  Transaction -> ReactUpdatesFlushTransaction: **close**

end

@enduml